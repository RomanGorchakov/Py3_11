Горчаков Роман Владимирович. Вариант 2
# Лабораторная работа 2.24. Синхронизация потоков в языке программирования Python

Для синхронизации доступа к ресурсам из нескольких потоков Python предоставляет набор объектов, каждый из которых обладает рядом особенностей, делающих их пригодными для решения некоторой группы специфических задач.

Lock-объект может находится в двух состояниях: захваченное (заблокированное) и незахваченное (не заблокированное, свободное). После создания он находится в свободном состоянии. Для работы с Lock-объектом используются методы acquire() и release(). Если Lock свободен, то вызов метода acquire() переводит его в заблокированное состояние. Повторный вызов acquire() приведет к блокировке инициировавшего это действие потока до тех пор, пока Lock не будет разблокирован каким-то другим потоком с помощью метода release(). Вывоз метода release() на свободном Lock-объекте приведет к выбросу исключения RuntimeError. Параметры метода:
* blocking – если параметр равен True, то при вызове на захваченном Lock-объекте выполнение потока остановится, после того как захват будет произведет, метод вернет True. Если параметр равен False, то при вызове на захваченном Lock-объекте поток не будет заблокирован и метод вернет False, если захват будет произведет, то вернет True;
* timeout – задает время, в течении которого поток будет находиться в заблокированном состоянии при попытке захватить уже занятый Lock-объект. Если в течении заданного времени поток не освободится, то метод вернет значение False.

При успешном захвате Lock-объекта, метод acquire() возвращает значение True. У Lock-объекта также есть метод locked(), который возвращает True если объект захвачен, False в противном случае. Освободить Lock-объект может любой поток (на обязательно тот, который вызвал acquire()). Хорошей практикой при работе с Lock-объектами является помещение кода работы с разделяемым ресурсом в блоке try, а освобождать блокировку следует в finally.

В отличии от рассмотренного выше Lock-объекта RLock может освободить только тот поток, который его захватил. Повторный захват потоком уже захваченного RLock-объекта не блокирует его. RLock-объекты поддерживают возможность вложенного захвата, при этом освобождение происходит только после того, как был выполнен release() для внешнего acquire(). Сигнатуры и назначение методов release() и acquire() RLock-объектов совпадают с приведенными для Lock, но в отличии от него у RLock нет метода locked(). RLock-объекты поддерживают протокол менеджера контекста.

Основное назначение условных переменных – это синхронизация работы потоков, которая предполагает ожидание готовности некоторого ресурса и оповещение об этом событии. Наиболее явно такой тип работы выражен в паттерне Producer-Consumer (Производитель – Потребитель). Условные переменные для организации работы внутри себя используют Lock- или RLock-объекты, захватом и освобождением которых управлять не придется, хотя и возможно, если возникнет такая необходимость.

При создании объекта Condition вы можете передать в конструктор объект Lock или RLock, с которым хотите работать. Перечислим методы объекта Condition с кратким описанием:
* acquire(*args) – захват объекта-блокировки;
* release() – освобождение объекта-блокировки;
* wait(timeout=None) – блокировка выполнения потока до оповещения о снятии блокировки. Через параметр timeout можно задать время ожидания оповещения о снятии блокировки. Если вызвать wait() на Условной переменной, у которой предварительно не был вызван acquire(), то будет выброшено исключение RuntimeError;
* wait_for(predicate, timeout=None) – метод позволяет сократить количество кода, которое нужно написать для контроля готовности ресурса и ожидания оповещения;
* notify(n=1) – снимает блокировку с остановленного методом wait() потока. Если необходимо разблокировать несколько потоков, то для этого следует передать их количество через аргумент n;
* notify_all() – снимает блокировку со всех остановленных методом wait() потоков.

Реализация классического семафора, предложенного Дейкстрой. Суть его идеи заключается в том, при каждом вызове метода acquire() происходит уменьшение счетчика семафора на единицу, а при вызове release() – увеличение. Значение счетчика не может быть меньше нуля, если на момент вызова acquire() его значение равно нулю, то происходит блокировка потока до тех пор, пока не будет вызван release(). Для работы с семафорами в Python есть класс Semaphore, при создании его объекта можно указать начальное значение счетчика через параметр value. Semaphore предоставляет два метода:
* acquire(blocking=True, timeout=None) – если значение внутреннего счетчика больше нуля, то счетчик уменьшается на единицу и метод возвращает True. Если значение счетчика равно нулю, то вызвавший данный метод поток блокируется, до тех пор, пока не будет кем-то вызван метод release(). Дополнительно при вызове метода можно указать параметры blocking и timeout, их назначение совпадает с acquire() для Lock;
* release() – увеличивает значение внутреннего счетчика на единицу.

Существует ещё один класс, реализующий алгоритм семафора BoundedSemaphore, в отличии от Semaphore, он проверяет, чтобы значение внутреннего счетчика было не больше того, что передано при создании объекта через аргумент value, если это происходит, то выбрасывается исключение ValueError. С помощью семафоров удобно управлять доступом к ресурсу, который имеет ограничение на количество одновременных обращений к нему (например, количество подключений к базе данных и т.п.)

События по своему назначению и алгоритму работы похожи на рассмотренные ранее условные переменные. Основная задача, которую они решают – это взаимодействие между потоками через механизм оповещения. Объект класса Event управляет внутренним флагом, который сбрасывается с помощью метода clear() и устанавливается методом set(). Потоки, которые используют объект Event для синхронизации блокируются при вызове метода wait(), если флаг сброшен. Методы класса Event:
* is_set() – возвращает True если флаг находится в взведенном состоянии;
* set() – переводит флаг в взведенное состояние;
* clear() – переводит флаг в сброшенное состояние;
* wait(timeout=None) – блокирует вызвавший данный метод поток если флаг соответствующего Event-объекта находится в сброшенном состоянии. Время нахождения в состоянии блокировки можно задать через параметр timeout.

Модуль threading предоставляет удобный инструмент для запуска задач по таймеру – класс Timer. При создании таймера указывается функция, которая будет выполнена, когда он сработает. Timer реализован как поток, является наследником от Thread, поэтому для его запуска необходимо вызвать start(), если необходимо остановить работу таймера, то вызовите cancel(). Параметры:
* interval – количество секунд, по истечении которых будет вызвана функция function;
* function – функция, вызов которой нужно осуществить по таймеру;
* args, kwargs – аргументы функции function.

Последний инструмент для синхронизации работы потоков, который мы рассмотрим является Barrier. Он позволяет реализовать алгоритм, когда необходимо дождаться завершения работы группы потоков, прежде чем продолжить выполнение задачи. Параметры:
* parties – количество потоков, которые будут работать в рамках барьера;
* action – определяет функцию, которая будет вызвана, когда потоки будут освобождены (достигнут барьера);
* timeout – таймаут, который будет использовать как значение по умолчанию для методов wait().

Свойства и методы класса:
* wait(timeout=None) – блокирует работу потока до тех пор, пока не будет получено уведомление либо не пройдет время указанное в timeout;
* reset() – переводит Barrier в исходное (пустое) состояние. Потокам, ожидающим уведомления, будет передано исключение BrokenBarrierError;
* abort() – останавливает работу барьера, переводит его в состояние “разрушен” (broken). Все текущие и последующие вызовы метода wait() будут завершены с ошибкой с выбросом исключения BrokenBarrierError;
* parties – количество потоков, которое нужно для достижения барьера;
* n_waiting – количество потоков, которое ожидает срабатывания барьера;
* broken – значение флага равное True указывает на то, что барьер находится в “разрушенном” состоянии.
